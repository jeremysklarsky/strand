<link rel="import" href="positionable.html">
<script type="text/javascript">
	
(function(scope) {
	
	var PositionableTip = {

		properties: {
			direction: {
				type: String,
				value: 's',
				reflectToAttribute: true
			},
			_tipSize: {
				type: Number,
				value: 15
			}
		},

		ready: function() {
			this._originalDirection = this.direction;
		},

		_updatePosition: function() {
			var winRect = this.windowMetrics,
				panelRect = this.metrics,
				targetRect = this.targetMetrics,
				offset = 0;

			this.direction = this._originalDirection;
			this._updateDirection(this.direction, panelRect, targetRect);	

			if(this.direction === 'n' || this.direction === 's') {

				offset = this._getOffset(panelRect.left, panelRect.right, winRect.left, winRect.right, panelRect.width, targetRect.width);
				// this.containerOffset = 'left: ' + containerOffset + 'px';
				this.$.container.style.left = offset + 'px';

				//window boundary flip:
				if(panelRect.top < winRect.top || panelRect.bottom > winRect.bottom) {
					this.direction = this._flipDirection(this.direction);
					this._updateDirection(this.direction, panelRect, targetRect);
				}
			} else {
				
				offset = this._getOffset(panelRect.top, panelRect.bottom, winRect.top, winRect.bottom, panelRect.height, targetRect.height);
				// this.containerOffset = 'top: ' + containerOffset + 'px';
				this.$.container.style.top = offset + 'px';

				//window boundary flip:
				if(panelRect.left < winRect.left || panelRect.right > winRect.right) {
					this.direction = this._flipDirection(this.direction);
					this._updateDirection(this.direction, panelRect, targetRect);
				}
			}

			panelRect.left -= this.targetMetrics.left - this.target.offsetLeft;
			panelRect.top -= this.targetMetrics.top - this.target.offsetTop;

			panelRect.toCSS(this);
			// this.style.transform = 'translate3d(' + panelRect.x + 'px, ' + panelRect.y + 'px, 0)';
		},

		_flipDirection: function(direction) {
			var index = this.DIRECTIONS.indexOf(direction);
			index = (index + 2) % this.DIRECTIONS.length;
			return this.DIRECTIONS[index];
		},

		_getOffset: function(panelA, panelB, boundaryA, boundaryB, panelSize, targetSize) {
			var offset = 0;
			var maxOffset = (panelSize - this.boundaryOffset * 2) / 2 - this._tipSize;

			if(panelA + offset < boundaryA) {
				offset = boundaryA - panelA;
			} else if(panelB + offset > boundaryB) {
				offset = boundaryB - panelB;
			}

			offset = Math.min(Math.max(offset, -maxOffset), maxOffset);

			return offset;
		},

		_updateDirection: function(direction, panelRect, targetRect) {
			var hCenter = targetRect.width / 2 - panelRect.width / 2;
			var vCenter = targetRect.height / 2 - panelRect.height / 2;
			
			switch(direction) {
				case 'n':
					panelRect.top = targetRect.top - panelRect.height - this.offset;
					panelRect.left = targetRect.left + hCenter;
					break;
				case 's':
					panelRect.top = targetRect.top + targetRect.height + this.offset;
					panelRect.left = targetRect.left + hCenter;
					break;
				case 'e':
					panelRect.top = targetRect.top + vCenter;
					panelRect.left = targetRect.left + targetRect.width + this.offset;
					break;
				case 'w':
					panelRect.top = targetRect.top + vCenter;
					panelRect.left = targetRect.left - panelRect.width - this.offset;
					break;
			}
		},

		DIRECTIONS: ['n', 'e', 's', 'w']


	};

	scope.PositionableTip = [
		scope.Positionable,
		PositionableTip
	];

})(window.StrandTraits = window.StrandTraits || {});
</script>